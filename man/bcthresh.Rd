% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bcthresh.R
\name{bcthresh}
\alias{bcthresh}
\title{Threshold selection in the i.i.d. case, assisted by Box-Cox transformation}
\usage{
bcthresh(data, probs, lambda, ..., n_v = 1, npy = NULL,
  use_rcpp = TRUE)
}
\arguments{
\item{data}{A numeric vector of observations.  Any missing values will
be removed.  The argument \code{npy} (see below) may be supplied
as an attribute of \code{data} using \code{attr(data, "npy") <- value},
where \code{value} is the value of \code{npy} (see \code{\link{attr}}).
If \code{npy} is supplied twice, as both \code{attr(data, "npy")})
and using the \code{npy} argument, then the former is used.}

\item{probs}{A numeric vector of non-exceedance probabilities in [0, 1).
\code{\link[stats]{quantile}}, specifically
\code{u_vec = stats::quantile(data, probs)}, is used to set a vector
\code{u_vec} of \emph{training} thresholds for use on the untransformed
(\eqn{\lambda = 1}) data scale.}

\item{lambda}{A numeric vector containing values of the Box-Cox
transformation parameter \eqn{\lambda}.  See \strong{Details} for advice
on setting \code{lambda}.}

\item{...}{Further (optional) arguments to be passed to the
  \code{\link[revdbayes]{revdbayes}} function
  \code{\link[revdbayes]{rpost_rcpp}} (or \code{\link[revdbayes]{rpost}}),
  which use the generalized ratio-of-uniforms method to simulate from
  extreme value posterior distributions.
  In particular:
\itemize{
  \item {\code{n}} {The size of the posterior sample used to perform
    predictive inference.  Default: \code{n = 1000}.}
  \item {\code{prior}} {A prior for GP parameters to be passed to the
    \strong{revdbayes} function \code{\link[revdbayes]{set_prior}}.
    Can be either a character scalar that chooses an in-built prior,
    or a user-supplied R function or pointer to a compiled C++ function.
    See the \code{\link[revdbayes]{set_prior}} documentation for details
    of the in-built priors.
    See the \strong{revdbayes} vignette
    \href{https://cran.r-project.org/package=revdbayes}{Faster simulation
    using revdbayes} for information about creating
    a pointer to a C++ function.  See also the \strong{Examples} section.

    If the user supplies and R function then \code{\link{rpost}} will be
    used for posterior simulation, rather than (the faster)
    \code{\link{rpost_rcpp}}, regardless of the input value of
    \code{use_rcpp}.

    Default: \code{prior = "mdi"} with \code{a = 0.6} and \code{min_xi = -1}.
    This particular prior is studied in
    \href{https://doi.org/10.1111/rssc.12159}{Northrop et al. (2017)}}.
  \item {\code{h_prior}} {A \emph{list} of further arguments
    (hyperparameters) for the GP prior specified in \code{prior}.}
  \item {\code{bin_prior}} {A prior for the threshold exceedance probability
    \eqn{p} to be passed to the \strong{revdbayes} function
    \code{\link[revdbayes]{set_bin_prior}}.
    Can either be a character scalar that chooses an in-built prior,
    or a user_supplied R function.

    Default: \code{prior = "jeffreys"}, i.e. Beta(1/2, 1/2).}
  \item {\code{h_bin_prior}} {A \emph{list} of further arguments
    (hyperparameters) for the binomial prior specified in \code{bin_prior}.
    See the \code{\link[revdbayes]{set_bin_prior}} documentation for details
    of the in-built priors.}
  \item {\code{trans}} {A character scalar: either \code{"none"} or
    \code{"BC"}.  See \code{\link{rpost_rcpp}} for details.
    The default is \code{"none"}, which is usually faster than \code{"BC"}.
    However, if there are very few threshold excesses then using
    \code{trans = "BC"} can make the optimizations involved in the
    generalized ratio-of-uniforms algorithm more stable.  If using
    \code{trans = "none"} produces an error for a particular posterior
    simulation then \code{trans = "BC"} is used instead.}
}}

\item{n_v}{A numeric scalar.
Each of the \code{n_v} largest values in \code{u_vec} will be used
(separately) as a \emph{validation} threshold for the training thresholds
in \code{u_vec} that lie at or below that validation threshold.
If \code{n_v = 1} then all the training thresholds are used with
validation performed using the threshold \code{u_vec[length(u_vec)]}.
If \code{n_v = 2} then, in addition, the assessment is performed using
\code{u_vec[1], ..., u_vec[length(u_vec) - 1]} with
validation threshold \code{u_vec[length(u_vec) - 1]},
and so on.}

\item{npy}{A numeric scalar. The mean number of observations per year
  of data, after excluding any missing values, i.e. the number of
  non-missing observations divided by total number of years of non-missing
  data.  May be supplied using as an attribute \code{attr(data, "npy")}
  of \code{data} instead.

  The value of \code{npy} does not affect any calculation in
  \code{ithresh}, it only affects subsequent extreme value inferences using
  \code{predict.ithresh}.  However, setting \code{npy} in the call to
  \code{rpost}, or as an attribute of \code{data} avoids the need to
  supply \code{npy} when calling \code{predict.ithresh}.}

\item{use_rcpp}{A logical scalar.  If \code{TRUE} (the default) the
revdbayes function \code{\link[revdbayes]{rpost_rcpp}} is used for
posterior simulation.  If \code{FALSE}, or if the user supplies an R
function to set the prior for GP parameters,
the (slower) function \code{\link[revdbayes]{rpost}} is used.}
}
\value{
An object (list) of class \code{"bcthresh"}, containing the
  components
  \itemize{
    \item{\code{pred_perf}:} A numeric array with dimensions
      \code{length(probs)} (the number of training thresholds),
      \code{length(n_v)} (the number of validation thresholds)
      and \code{length(lambda)} (the number of values of \eqn{lambda}),
      containing the respective values of the measures predictive
      performance.
      \code{as.matrix(pred_perf[ , , i])} is an \code{length(probs)} by
      \code{length(n_v)} matrix resulting from the analysis that uses
      \eqn{\lambda} = \code{lambda[i]}.
      Entries corresponding to cases where the training threshold is above
      the validation threshold will be \code{NA}.
    \item{\code{lambda}:} The argument \code{lambda} to \code{bcthresh}.
    \item{\code{lngm}:} The natural log of the geometric mean of the raw
      data \code{data}.
    \item{\code{u_vec}:} A numeric vector. The training thresholds (that
      would be) used for the raw data, i.e. when \eqn{\lambda = 1}.
    \item{\code{v_vec}:} A numeric vector. The validation thresholds (that
      would be) used for the raw data, i.e. when \eqn{\lambda = 1}.
    \item{\code{u_ps}:} A numeric vector. The approximate levels of the
      sample quantiles to which the values in \code{u_vec} correspond,
      i.e. the approximate percentage of the data the lie at or below
      each element in \code{u_vec}.
    \item{\code{v_ps}:} A numeric vector.  The values in \code{u_ps}
      that correspond to the validation thresholds.
    \item{\code{sim_vals}:} A numeric array with dimensions
    \code{n} x \code{length(u_vec)}, 4
    and \code{length(lambda)}.
    \code{as.matrix(sim_vals[ , , i])} is matrix in which the \eqn{j}th
      block of \code{n} rows contains in columns 1-3 the posterior samples
      of the threshold exceedance probability, the GP scale
      parameter and the GP shape parameter respectively,
      based on training threshold \code{u_vec[i]},
      and in column 4 the value of \eqn{j}.
    \item{\code{n}:} A numeric scalar.  The value of \code{n}.
    \item{\code{npy}:} A numeric scalar.  The value of \code{npy}.
    \item{\code{data}:} The argument \code{data} to \code{bcthresh}
      detailed above, with any missing values removed.
    \item{\code{use_rcpp}:} A logical scalar indicating whether
      \code{\link[revdbayes]{rpost_rcpp}} (\code{use_rcpp = TRUE}) or
      \code{\link[revdbayes]{rpost}} (\code{use_rcpp = FALSE})
      was used for posterior simulation.
    \item{\code{for_post}:} A list containing arguments with which
      \code{\link[revdbayes]{rpost_rcpp}}
      (or \code{\link[revdbayes]{rpost}}) was called, including
      any user-supplied arguments to these functions.
  }
}
\description{
Uses the function \code{\link{ithresh}} to assist in the selection of
an extreme value threshold after transforming the data with a Box-Cox
transformation.  The general aim is to seek a Box-Cox transformation
parameter \eqn{\lambda} for which we can set a relatively low threshold,
that is, a threshold that has a larger number of threshold excesses than
for other values of \eqn{\lambda}.  For
}
\details{
See \code{\link{ithresh}} and/or
  \href{https://doi.org/10.1111/rssc.12159}{Northrop et al. (2017)}
  for details of the threshold selection algorithm that is applied
  for a given value of \eqn{\lambda}.  The measure of predictive
  performance is calculated on the scale of the raw (\eqn{\lambda = 1})
  data, in order that values resulting from different values of
  \eqn{\lambda} can be compared.

  \strong{Setting \code{lambda}}.  The function \code{\link{choose_b}}
    can be used to extract results for a chosen value of \eqn{\lambda}.
}
\examples{
# Note:
# 1. Smoother plots result from making n larger than the default n = 1000.
# 2. In some examples below validation thresholds rather higher than is
#    advisable have been used, with far fewer excesses than the minimum of
#    50 suggested by Jonathan and Ewans (2013).

# Set a prior: flat for GP parameters, Haldane for P(exceedance)
prior_args <- list(prior = "flatflat", bin_prior = "haldane",
                   h_prior = list(min_xi = -Inf))

## Gulf of Mexico significant wave heights ------------------

gom_probs <- seq(0.1, 0.9, 0.1)
gom_lambda <- seq(1, 3, 0.5)
gom_args <- list(data = gom, probs = gom_probs, lambda = gom_lambda)
gom_lambda <- do.call(bcthresh, c(gom_args, prior_args))

## North Sea significant wave heights -----------------------

ns_probs <- seq(0.1, 0.9, 0.1)
ns_lambda <- seq(-1/2, 2, 0.5)
ns_args <- list(data = ns, probs = ns_probs, lambda = ns_lambda, trans = "BC")
ns_lambda <- do.call(bcthresh, c(ns_args, prior_args))

# Exponentiated exponential data ----------------------------

exp_probs <- seq(0, 0.9, 0.1)
exp_lambda <- seq(0, 1, 0.5)
set.seed(49)
y <- rexp(1000)
x <- exp(y)
exp_args <- list(data = x, probs = exp_probs, lambda = exp_lambda)
log_exp <- do.call(bcthresh, c(exp_args, prior_args))
}
\references{
Jonathan, P. and Ewans, K. (2013) Statistical modelling
  of extreme ocean environments for marine design : a review.
  \emph{Ocean Engineering}, \strong{62}, 91-109.
  \url{http://dx.doi.org/10.1016/j.oceaneng.2013.01.004}

Northrop, P. J., Attalides, N. and Jonathan, P. (2017)
  Cross-validatory extreme value threshold selection and uncertainty
  with application to ocean storm severity.
  \emph{Journal of the Royal Statistical Society Series C: Applied
  Statistics}, \strong{66}(1), 93-120.
  \url{http://dx.doi.org/10.1111/rssc.12159}
}
\seealso{
\code{\link{ithresh}} for threshold selection in the i.i.d. case
  (using \eqn{\lambda = 1}).

\code{\link{choose_lambda}} to extract results for a chosen value
  of \eqn{\lambda}.

\code{\link[revdbayes]{rpost}} in the
  \code{\link[revdbayes]{revdbayes}} package for details of the arguments
  that can be passed to
  \code{\link[revdbayes]{rpost_rcpp}}/\code{\link[revdbayes]{rpost}}.

\code{\link[revdbayes]{set_prior}} and
  \code{\link[revdbayes]{set_bin_prior}} in the
  \code{\link[revdbayes]{revdbayes}} package for details of how to set a
  prior distributions for GP parameters and for the exceedance probability
  \eqn{p}.

\code{\link[stats]{quantile}}.
}
